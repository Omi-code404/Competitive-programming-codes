# Problem: Sum of Round Numbers (Codeforces 1352A)

## Problem Description
Given a positive integer n (1 ≤ n ≤ 10,000), decompose it into the *minimum number of round numbers*
such that their sum equals n. A *round number* is defined as a number where all digits
except the leftmost (most significant) digit are zero (e.g., 5000, 1, 9, 800, 90).
## Input
- The first line contains t (number of test cases, 1 ≤ t ≤ 10,000).
- Each of the next t lines contains an integer n (1 ≤ n ≤ 10,000).

### Output
For each test case:
1. Print k (the minimum number of round numbers).
2. Print the k round numbers in any order.
## Approach
1. *Extract Non-Zero Digits*: For each digit in n (from right to left), if the digit is non-zero, multiply it by the appropriate power of 10 (based on its position) to form a round number.
2. *Count Round Numbers*: The number of non-zero digits in n determines the minimum number of round numbers needed.
3. *Output the Result*: Print the count followed by the round numbers.

### Time Complexity:  
- *O(t * d)*, where d is the number of digits in n (max d = 5 for n ≤ 10,000).  
- Efficient for given constraints.

### Space Complexity:  
- *O(1)* per test case (only stores up to 5 round numbers).
### Solution code:
#include <stdio.h>

void decompose(int n) {
    int round_numbers[5];
    int count = 0;
    int multiplier = 1;
    
    while (n > 0) {
        int digit = n % 10;
        if (digit != 0) {
            round_numbers[count++] = digit * multiplier;
        }
        n /= 10;
        multiplier *= 10;
    }
    
    printf("%d\n", count);
    for (int i = 0; i < count; i++) {
        printf("%d ", round_numbers[i]);
    }
    printf("\n");
}

int main() {
    int t, n;
    scanf("%d", &t);
    
    while (t--) {
        scanf("%d", &n);
        decompose(n);
    }
    
    return 0;
}
**Input:**  

5
5009
7
9876
10000
10

**Output:**  

2
5000 9 
1
7 
4
800 70 6 9000 
1
10000 
1
10 


